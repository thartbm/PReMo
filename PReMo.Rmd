---
title: "PReMo"
output:
  word_document: default
  html_notebook: default
---

This notebook implements the model from this paper: [Proprioceptive Re-alignment drives Implicit Sensorimotor Adaptation](https://doi.org/10.1101/2021.12.21.473747)

# Equations

**Eq. 1** gives the integrated estimate of the felt hand position:

$x_{p,t}^I = \frac{\sigma_u^2}{\sigma_u^2+\sigma_p^2}x_{p,t} + \frac{\sigma_p^2}{\sigma_u^2+\sigma_p^2}G_t$

```{r}
F_xI_pt <- function(x_pt, var_u, var_p, Gt) {
  
  wx_pt <- (var_u/(var_u+var_p)) * x_pt
  wGt   <- (var_p/(var_u+var_p)) * Gt
  
  return(w_xpt + w_Gt)
  
}
```

**Eq. 2** gives the integrated estimate of the visual hand position:

$x_{v,t}^I = \frac{\sigma_u^2}{\sigma_u^2+\sigma_v^2}x_{p,t} + \frac{\sigma_p^2}{\sigma_u^2+\sigma_v^2}G_t$

```{r}
F_xI_vt <- function(x_vt, var_u, var_v, var_p, Gt) {
  
  Wx_vt <- (var_u/(var_u+var_v)) * x_vt
  WGt   <- (var_p/(var_u+var_v)) * Gt
  
  return(Wx_vt + WGt)
  
}
```


**Eq. 3** gives the "intramodel integrated estimate of hand position", recalibrated crossmodally by vision:

$x_{p,t}^{per} = x_{p,t}^I + \beta_p$

Where $\beta_p$ is the proprioceptive shift.

```{r}
F_xper_pt <- function(xI_pt, beta_p) {
  
  return(xI_pt + beta_p)
  
}
```

**Eq. 4** gives the "intramodel integrated estimate of cursor position", recalibrated by proprioception:

$x_{v,t}^{per} = x_{v,t}^I + \beta_v$

Where $\beta_v$ is the visual shift.

```{r}
F_xper_vt <- function(xI_vt, beta_v) {
  
  return(xI_vt + beta_v)
  
}
```

The the visual and proprioceptive shifts are given in equations 5 and 6, where each is first a fixed ratio of the visuo-proprioceptive discrepancy ($x_{v,t}^I - x_{p,t}^I$) depending on which modality is used ($\eta_p, \eta_v$), and for larger rotations, both are capped by some level of saturation ($\beta_{p,sat}, \beta_{v,sat}$):

$\beta_{p,t} = min[\eta_p(x_{v,t}^I - x_{p,t}^I), \beta_{p,sat}]$

$\beta_{v,t} = min[\eta_v(x_{v,t}^I - x_{p,t}^I), \beta_{v,sat}]$

```{r}
F_beta_pt <- function(eta_p, xI_vt, xI_pt, beta_psat) {
  
  return( min(eta_p*(xI_vt - xI_pt), beta_psat) )
  
}

F_beta_vt <- function(eta_v, xI_vt, xI_pt, beta_vsat) {
  
  return( min(eta_v*(xI_vt - xI_pt), beta_vsat) )
  
}
```

Then proprioceptive error is given as the difference between the movement goal and the perceived proprioceptive hand position:

**Eq. 7**:

$PropError = G_t - x_{p,t}^{per}$

```{r}
F_PropError <- function(G_t, xper_pt) {
  
  return(G_t - xper_pt)
  
}
```

In **Eq. 8**, the state space model is updated with a learning rate $K$:

$x_{p,t+1}=x_{p,t}+K(G_t - x_{p,t}^{per})$

And $x_{p,t}$ is used as the _actual_ hand position in Eq 1.

```{r}
F_x_pt1 <- function(x_pt, K, G_t, xper_pt) {
  
  return(x_pt + (K*(G_t - xper_pt)))
  
}
```

**Eq. 9** embodies the key assumption of PReMo that the upper bound of adaptation ($x_p^{UB}$) is reached when there is no more proprioceptive error, that is: when the perceived hand position is the same as the perceived motor goal.

$x_p^{UB} = \frac{-\beta_p(\sigma_u^2 + \sigma_p^2)}{\sigma_u^2}$

```{r}
F_xUB_p <- function(beta_p, var_u, var_p) {
  
  return( (-beta_p(var_u + var_p))/var_u )
  
}
```

**Eq. 10** is actually the same as **Eq. 9** and perhaps neither needs to be incorporated in the model, it seems they roll out of the model instead:

$x_p^{UB} = -\beta_p - \beta_p\frac{\sigma_p^2}{\sigma_u^2}$

Seems to me like the other equations are not part of the model per se, but rather predict upper bounds and some other stuff happening in the model.

# Variables

Below is a list of variables and their origin.

All variables with a $t$ subscript vary over trials/time, i.e. they will be changed by the state-space model.

| variable: | meaning: | origin: | JT: |
| ------- | ------------ | ---------- | --- |
| $\sigma_u^2$ | uncertainty of (unified) sensory predictions | ? (literature?) | free |
| $\sigma_p^2$ | proprioceptive uncertainty | literature: ~$8^{\circ}$, see Fig 3 | free |
| $\sigma_v^2$ | visual uncertainty | ? (literature?) | free |
| $K$ | learning rate | fit | free |
| $\eta_p$ | proprioceptive recalibration ratio | fit | free |
| $\eta_v$ | visual recalibration ratio | fit | free |
| $\beta_{p,sat}$ | maximum proprioceptive shift | literature: $5^{\circ}$, Ruttle et al., 2021 | free? |
| $\beta_{v,sat}$ | maximum visual shift | literature: $1^{\circ}$, Tsay et al., 2020 | free? |
| $\beta_{p,t}$ | proprioceptive shift | Eq. 5 | free |
| $\beta_{v,t}$ | visual shift | Eq. 6 | free |
| $x_{p,t}^I$ | integrated proprioceptive estimate of hand position | Eq. 1 | latent |
| $x_{v,t}^I$ | integrated visual estimate of cursor position | Eq. 2 | latent |
| $x_{p,t+1}$  | subsequent motor command | Eq. 8 | latent? |
| $x_{p,t}$ | actual hand position | current reach | output |
| $x_{v,t}$ | actual cursor position | the current trial's feedback | output |
| $x_{p,t}^{per}$ | perceived hand position | Eq. 3 | output |
| $x_{v,t}^{per}$ | perceived cursor position | Eq. 4 | output |
| $G_t$ | proprioceptive goal | aim? 0 for fully implicit adaptation | ? |

# Model functions

Since some of the parameters could be set from the literature whereas others could be fit, we implement the model with two sets of parameters: `parfree` and `parset` as inputs, so that any fitting algorithm can fit the free parameters and not touch the set parameters. I will keep this a fully implicit model, so that `Gt=0` throughout. It will also need a perturbation schedule:

```{r}
PReMo_model <- function(parfree, parset, schedule) {
  
  # we want all the parameters in 1 vector:
  p <- c(parfree, parset)
  
  # so that we can read them out as variables here:
  var_u     <- p['var_u']
  var_p     <- p['var_p']
  var_v     <- p['var_v']
  eta_p     <- p['eta_p']
  eta_v     <- p['eta_v']
  beta_psat <- p['beta_psat']
  beta_vsat <- p['beta_vsat']
  K         <- p['K']
  
  # initialize the state:
  x_pt    <- 0
  x_vt    <- 0
  beta_pt <- 0
  beta_vt <- 0
  Gt      <- 0 # this will be kept 0, could increase for explicit re-aiming
  
  # empty vectors:
  reach <- c()
  prop  <- c()
  handp <- c()
  cursp <- c()
  
  for (trial in c(1:length(schedule))) {
    
    # Marius' added line:
    x_vt <- x_pt + schedule[trial]
    
    # Eq. 1
    # integrated proprioceptive position:
    xI_pt <- ( (var_u/(var_u+var_p)) * x_pt ) + ( (var_p/(var_u+var_p)) * Gt )

    # Eq. 2
    # integrated visual position:
    xI_vt <-  ( (var_u/(var_u+var_v)) * x_vt ) + ( (var_p/(var_u+var_v)) * Gt )
    
    # Eq. 3
    # perceived proprioceptive position:
    xper_pt <- xI_pt + beta_pt
    
    # Eq. 4
    # perceived visual position:
    xper_vt <- xI_vt + beta_vt
    
    # Eq. 5
    # reported proprioceptive shift:
    beta_pt <- min(eta_p*(xI_vt - xI_pt), beta_psat)
    
    # Eq. 6
    # reported visual shift:
    beta_vt <- min(eta_p*(xI_vt - xI_pt), beta_vsat)
    

    # store stuff in vectors:
    reach <- c(reach, x_pt)
    prop  <- c(prop,  beta_pt)
    
    handp <- c(handp, xI_pt)
    cursp <- c(cursp, xI_vt)
    
    
    # Eq. 8 (and 7)
    # reach direction on next trial:
    x_pt <- x_pt + (K*(Gt - xper_pt))

    
  }
  
  return(data.frame(reach, prop, handp, cursp))

}

```

Test if this gives any useful output:

```{r}

parset <- c('var_u'     = 1,
            'var_p'     = 7,
            'var_v'     = 0.1,
            'beta_psat' = 5,
            'beta_vsat' = 1)
  
parfree <- c('K'        = 0.50,
             'eta_p'    = 0.50,
             'eta_v'    = 0.50)

# a rotation of 30 degrees introduced on trial 21:
schedule <- c(rep(0,20),rep(30,80))

behavior <- PReMo_model(parfree, parset, schedule)

plot(-1000,-1000,main='',xlab='',ylab='',xlim=c(0,101), ylim=c(-30,30))
for (trial in c(20,21,22)) {lines(c(trial,trial),c(-35,35),col='gray')}
lines( schedule, col='black')
lines(-schedule, col='black')
lines(behavior$reach, col='blue')
lines(behavior$prop, col='red')
```

OK, seems to work... kind of.

```{r}
PReMo_errors <- function(parfree, parset, schedule, reaches=NULL, proprioception=NULL) {
  
  # this will compare model output to reaches, or proprioception, or both
  # but not neither
  
  if (is.null(reaches) & is.null(proprioception)) {
    return(Inf) # dangerous value (might change later), but model should not be compared to no data at all
  }
  # can do more checks, such as that if these variables are not null they are: 
  # - some kind of numeric vector
  # - with length equal to schedule
  
  # actually, it might be nicer to have all sorts of behavior in a data.frame or matrix
  # and compare with columns in the behavioral output that have the same name?
  # not now...
  
  # run model with current parameters:
  behavior <- PReMo_model(parfree, parset, schedule)
  
  # collect errors here:
  errors <- c()
  
  if (!is.null(reaches)) {
    errors <- c(errors, behavior$reach - reaches)
  }
  
  if (!is.null(proprioception)) {
    errors <- c(errors, behavior$prop - proprioception)
  }
  
  errors <- errors[!is.na(errors)]
  
  return(sum(errors^2))
  
}
```

Let's see if that kind of works... we need some data first.

Download Jennifer's 2021 data with proprioception:

```{r}
active_localizations  <- read.csv(url('https://osf.io/mc523/download'), stringsAsFactors = FALSE)
active_reaches        <- read.csv(url('https://osf.io/ejxy9/download'), stringsAsFactors = FALSE)
passive_localizations <- read.csv(url('https://osf.io/9r6gj/download'), stringsAsFactors = FALSE)
passive_reaches       <- read.csv(url('https://osf.io/mq5av/download'), stringsAsFactors = FALSE)
```

Get group averages:

```{r}

schedule      <- active_reaches$distortion

act_prop      <- as.numeric( rowMeans( active_localizations[,c(2:33)], na.rm=TRUE ) )
pas_prop      <- as.numeric( rowMeans( passive_localizations[,c(2:33)], na.rm=TRUE ) )

act_adapt     <- as.numeric( rowMeans( active_reaches[,c(2:33)], na.rm=TRUE) )
pas_adapt     <- as.numeric( rowMeans( passive_reaches[,c(2:33)], na.rm=TRUE) )
```

Let's see what kind of data we have here (active group only for now):

```{r}
plot(schedule, type='l', main='', xlab='', ylab='', col='black')
lines(act_adapt, col='red')
lines(act_prop, col='blue')
```
Alright, so we could fit the model to this data. Let's first test if the error function is reasonable.

```{r}

parset <- c('var_u'     = 1,
            'var_p'     = 7,
            'var_v'     = 0.1,
            'beta_psat' = 5,
            'beta_vsat' = 1)
  
parfree <- c('K'        = 0.50,
             'eta_p'    = 0.50,
             'eta_v'    = 0.50)

reach_MSE <- PReMo_errors(parfree, parset, schedule, reaches=act_adapt)
print(reach_MSE)

prop_MSE <- PReMo_errors(parfree, parset, schedule, proprioception=act_prop)
print(prop_MSE)

both_MSE <- PReMo_errors(parfree, parset, schedule, reaches=act_adapt, proprioception=act_prop)
print(both_MSE)
```
Looks reasonable, now let's write a fitting function:

```{r}
library(optimx)

PReMo_fit <- function(schedule, reaches=NULL, proprioception=NULL) {
  
  parset <- c('var_u'     = 1,
              'var_p'     = 7,
              'var_v'     = 0.1,
              'beta_psat' = 5,
              'beta_vsat' = 1)
  
  # parfree <- c('K'        = 0.50,
  #              'eta_p'    = 0.50,
  #              'eta_v'    = 0.50)
  
  # The free parameters will first be probed in a grid search:
  K     <- seq(0.05,0.95,0.10)
  eta_p <- seq(0.05,0.95,0.10) # do I have the bounds for these parameters right?
  eta_v <- seq(0.05,0.95,0.10)
  
  searchgrid <- expand.grid('K'=K, 'eta_p'=eta_p, 'eta_v'=eta_v)
  
  MSEs <- apply(searchgrid,FUN=PReMo_errors,MARGIN=c(1),schedule=schedule,parset=parset,reaches=reaches,proprioception=proprioception)
  
  topgrid <- searchgrid[order(MSEs)[c(1,2,5,10,20)],]
  
  # do fitting on the best results from the search grid:
  topFits <- do.call("rbind",
                         apply( topgrid,
                                MARGIN=c(1),
                                FUN=optimx::optimx,
                                fn=PReMo_errors,
                                method='L-BFGS-B',
                                lower=c(0.001,0.001,0.001),
                                upper=c(0.999,0.999,0.999),
                                schedule=schedule,
                                parset=parset,
                                reaches=reaches,
                                proprioception=proprioception) )
  
  winFit <- topFits[order(topFits$value)[1],]

  winpar <- as.numeric(winFit[1:3])
  names(winpar) <- names(winFit[1:3])
  
  return(winpar)
  
}

PReMo_par <- PReMo_fit(schedule=schedule,
                       reaches=reaches,
                       proprioception=proprioception)

```

Now plot the fit on top of the data:

```{r}

behavior <- PReMo_model(parfree=PReMo_par, parset=parset, schedule=schedule)

plot(schedule, type='l', main='', xlab='', ylab='', col='black')
lines(act_adapt, col='red')
lines(act_prop, col='blue')
lines(behavior$reach, col='blue')
lines(behavior$prop, col='red')
```

